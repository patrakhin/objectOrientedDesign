Рефлексия задания 4.
Тип АТД определен верно.
Конструктор реализован верно. Некорректное постусловие в части: «фиксированного размера»

    //предусловие: массив создается впервые
    //постусловие: добавляется новый объект в хвост массива
    //постусловие: создается условие для увеличения размера массива, если будет произведена эта операция еще раз
    public void Append(T); //команда
•	Предусловие не нужно
•	Лишнее постусловие (создается условие для увеличения размера массива, если будет произведена эта операция еще раз)

    //предусловие: массив не пустой
    //постусловие: освобождается ячейка для вставки нового значения
    //постусловие: создается условие для уменьшения размера массива
    public void Remove(int value); //команда
•	Предусловие не верно, нас интересует лежит ли индекс в границах массива или нет, а не наполненность массива (пуст он или нет)
•	Постусловия не верны, нас интересует удалился ли I элемент из массива.

    //предусловие: массив создается впервые
    //постусловие: добавляется новый объект по индексу
    //постусловие: создается условие для увеличения размера массива, если будет произведена эта операция еще раз
    public void Insert(T, int value); //команда
•	Данная команда аналогична эталонной по действию :   public void put(i, T value);но, пред и пост условия не верны.
Опять же, интересует, находится ли i элемент в границах массива и постусловие – значение i элемента изменено на value.

    // команды
    //предусловие: массив заданного размера создается впервые или текущий массив заданного размера полон
    //постусловие: массив увеличивается на заданный размер
    public void makeArray(int value); //команда
•	Данная команда не нужна, т.к. в процессе проектирования абстрактного класса, переходишь к деталям реализации,
смешивая два понятия: абстрактный класс и класс реализующий.

Команды:
  public void put_left(i, T value);
public void put_right(i, T value);
отсутствуют вообще. Т.к. изначально придерживался шаблона реализации динамического массива.
Соответственно, не смог абстрагироваться и выбрать следующую абстракцию:
добавляем значение по индексу, в любое место массива (проверяя, находится ли индекс в пределах массива)
и добавляем элементы в массив справа и слева от i-го элемента
(выполняя проверку на нахождение в границах i-го элемента, перед или после которого, добавиться новое значение.)

    //запросы
    //предусловие: массив не пустой
    //постусловие: нет
    public T getItem(int value); //запрос (чистая функция)
    public int size(); //запрос (чистая функция)
•	Запросы реализованы верно, но пост и пред условия ошибочны. Ошибочны из-за неверно выбранной стратегии построения АТД.
    //запросы статусов

    public int get_Insert_status; // возвращает значение INSERT_*
    public int get_Remove_status; // возвращает значение REMOVE_*
•	Запросы аналогичны, но реализованы не верно. public int get_remove_status() – так правильно.

    //запросы статусов
    public int get_makeArray_status; // возвращает значение MAKE_ARRAY_*
    public int get_Append_status; // возвращает значение APPEND_*
•	Запросы не верные, из-за неверной реализации АТД.
