Рефлексия задания 10.

Абстрактный класс описан верно.
Конструктор, описан верно.
Команды: не верно, т.к. предусловие не нужно, значение будет записано/обновлено в любом случае.
Из-за установленного (неверно) предусловия, соответственно и запросы статуса команды не нужны.

Рефлексии заданий (с 1 по 9):

Рефлексия задания 1.
На проверку предоставлять абстрактный класс (ссылкой), реализацию выполнять в том же проекте в some.java.
По сути, выполнен класс, где реализация АТД полностью присутствует, но класс, где реализация АТД полностью отсутствует не выполнен.
Статусы:
Отсутствуют комментарии у статусов.
Выполнен ненужный статус: public const int PUSH_NIL = 0; // подразумевалось, что команда еще не вызывалась.
Конструктор:
Отсутствует постусловие для конструктора.
Команды:
Отсутствуют пред и пост условия для public void push(T value).
Отсутствуют пред и пост условия для public void pop().
Отсутствует постусловие для public void pop().
Запросы:
Отсутствует постусловие для public T peek().
Отсутствует функция public int max_size().
Дополнительные запросы:
Отсутствует комментарий для public int get_pop_status().
Отсутствует комментарий для public int get_peek_status().
Отсутствует комментарий для public int get_push_status().

Ошибки следуют из неправильного подхода к выполнению задания.
Необходимо было создать абстрактный класс и уже на основе его,
выполнить класс реализующий АТД,
а не основываясь на выполненной реализации  class Stack<T> выполнять реализацию class BoundedStack<T>.

abstract class BoundedStack<T>
    public const int POP_NIL = 0; // отсутствует комментарий
    public const int POP_OK = 1; // отсутствует комментарий
    public const int POP_ERR = 2; // отсутствует комментарий

    public const int PEEK_NIL = 0; // отсутствует комментарий
    public const int PEEK_OK = 1; // отсутствует комментарий
    public const int PEEK_ERR = 2; // отсутствует комментарий

    public const int PUSH_NIL = 0; // ненужный статус
    public const int PUSH_OK = 1; // отсутствует комментарий
    public const int PUSH_ERR = 2; // отсутствует комментарий

    // конструктор
    //постусловие: создан новый пустой стек
    public BoundedStack<T>  BoundedStack(int maxSize);

    //команды
    //отсутствуют пред и пост условия
    public void push(T value);

    //отсутствуют пред и пост условия
    public void pop();

    //отсутствует постусловие
    public void pop();

    // запросы:
    // предусловие: отсутствует
    public T peek();

    public int size();

    // отсутствует функция
    public int max_size();

    // дополнительные запросы:
    public int get_pop_status(); // отсутствует комментарий
    public int get_peek_status(); // отсутствует комментарий
    public int get_push_status(); // отсутствует комментарий


Рефлексия задания 2.

В целом abstract class LinkedList<T> реализован.
Присутствуют необходимые элементы: конструктор, команды, запросы, запросы статусов (дополнительные запросы).
Разберем детально.
Конструктор:
Замечаний нет, реализован верно, постусловие описано верно.
Команды:
Отсутствуют команды для перемещения курсора, т.к. они были определены как чистые функции и соответственно, как запросы.
Следовательно, постусловия отсутствуют.
Это отсутствующие команды с пред и постусловиями:
// предусловие: список не пуст;
// постусловие: курсор установлен на первый узел в списке
  public void head();

// предусловие: список не пуст;
// постусловие: курсор установлен на последний узел в списке
  public void tail();

// предусловие: правее курсора есть элемент;
// постусловие: курсор сдвинут на один узел вправо
  public void right();

Далее, команды, с пред и пост условиями:
  public void put_right(T value);
  public void put_left(T value);
реализованы верно, пред и пост условия идентичны эталонному решению.
Команда public void remove() отсутствует вообще.
Команда   public void clear() написана верно с правильным постусловием
Команда   public void add_tail(T value) написана верно, постусловие не корректно в части того,
что новый узел добавлен в хвост списка а не как в решении -  «в список добавляется новое значение».
Команды:
 public void remove_all(T value) и public void replace(T value) написаны верно, пред и постусловия аналогичны эталонным.
Команда public void find(T value) описана верно, отсутствует постусловие.

Запросы:
public T get(); // предусловие: список не пуст
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();
определены верно.

Запросы статусов. Из за того что команды по перемещению курсора не были определены как команды,
а как функции, в запросах статусов отсутствуют:
public int get_head_status(); // успешно; список пуст
public int get_right_status(); // успешно; правее нету элемента

В целом, нужно запомнить следующее: (далее из конспекта)
2) Запросы -- методы, которые вычисляют некоторое значение на основе своих аргументов
(и возможно, на основе значений каких-то скрытых атрибутов класса),
но не меняют значения никаких атрибутов класса (не меняют состояние класса).
По сути, это чистые функции, которым требуются предусловия.
3) Команды, которые никакое значение не вычисляют, но меняют значения атрибутов класса,
меняют состояние класса (возможно, на основе своих аргументов). Для команд требуются постусловия.

Функция возвращает только то значение, которое напрямую от неё требуется по спецификации.
Команды вообще никакого значения не возвращают.

Тогда, управление курсором это команды, т.к. они меняют значение атрибутов (курсора).
Ведь при выполнении, к примеру, команды right, курсор будет указывать на определенный узел,
т.е. его состояние изменится.

Рефлексия задания 3.

//LinkedList
abstract class LinkedList<T> extends ParentList{};
//не указан/реализован конструктор согласно эталону: (// конструктор  public LinkedList<T> LinkedList();  )

//TwoWayList
    // запросы статусов (возможные значения статусов)
    public int get_left_status(); // успешно левее нету элемента

Пропущен знак препинания «успешно ;  левее ...», значения статусов воспринимаются не корректно

Рефлексия задания 4.
Тип АТД определен верно.
Конструктор реализован верно. Некорректное постусловие в части: «фиксированного размера»

    //предусловие: массив создается впервые
    //постусловие: добавляется новый объект в хвост массива
    //постусловие: создается условие для увеличения размера массива, если будет произведена эта операция еще раз
    public void Append(T); //команда
•	Предусловие не нужно
•	Лишнее постусловие (создается условие для увеличения размера массива, если будет произведена эта операция еще раз)

    //предусловие: массив не пустой
    //постусловие: освобождается ячейка для вставки нового значения
    //постусловие: создается условие для уменьшения размера массива
    public void Remove(int value); //команда
•	Предусловие не верно, нас интересует лежит ли индекс в границах массива или нет, а не наполненность массива (пуст он или нет)
•	Постусловия не верны, нас интересует удалился ли I элемент из массива.

    //предусловие: массив создается впервые
    //постусловие: добавляется новый объект по индексу
    //постусловие: создается условие для увеличения размера массива, если будет произведена эта операция еще раз
    public void Insert(T, int value); //команда
•	Данная команда аналогична эталонной по действию :   public void put(i, T value);но, пред и пост условия не верны.
Опять же, интересует, находится ли i элемент в границах массива и постусловие – значение i элемента изменено на value.

    // команды
    //предусловие: массив заданного размера создается впервые или текущий массив заданного размера полон
    //постусловие: массив увеличивается на заданный размер
    public void makeArray(int value); //команда
•	Данная команда не нужна, т.к. в процессе проектирования абстрактного класса, переходишь к деталям реализации,
смешивая два понятия: абстрактный класс и класс реализующий.

Команды:
  public void put_left(i, T value);
public void put_right(i, T value);
отсутствуют вообще. Т.к. изначально придерживался шаблона реализации динамического массива.
Соответственно, не смог абстрагироваться и выбрать следующую абстракцию:
добавляем значение по индексу, в любое место массива (проверяя, находится ли индекс в пределах массива)
и добавляем элементы в массив справа и слева от i-го элемента
(выполняя проверку на нахождение в границах i-го элемента, перед или после которого, добавиться новое значение.)

    //запросы
    //предусловие: массив не пустой
    //постусловие: нет
    public T getItem(int value); //запрос (чистая функция)
    public int size(); //запрос (чистая функция)
•	Запросы реализованы верно, но пост и пред условия ошибочны. Ошибочны из-за неверно выбранной стратегии построения АТД.
    //запросы статусов

    public int get_Insert_status; // возвращает значение INSERT_*
    public int get_Remove_status; // возвращает значение REMOVE_*
•	Запросы аналогичны, но реализованы не верно. public int get_remove_status() – так правильно.

    //запросы статусов
    public int get_makeArray_status; // возвращает значение MAKE_ARRAY_*
    public int get_Append_status; // возвращает значение APPEND_*
•	Запросы не верные, из-за неверной реализации АТД.

Рефлексия задания 5.

1.Тип АТД определен верно. Queue<T>

2.Сигнатуры методов АТД сформированы не верно, такие как:
public T removeHead();
в данном методе выполняется удаление элемента из очереди, с возвратом его значения (смешивается команда и запрос).
Нужно было сделать так.
Определить сигнатуру метода удаляющего элемент из головы очереди (public void dequeue();). – команда.
И определить сигнатуру метода получающего элемент из головы очереди (public T get();). – запрос.


3.Передусовия.

для команды: public void putTail(T value);( //предусловие: очередь полна) не нужно
– предусловие было указано, исходя из принятого ограничения на размер очереди.
(такого ограничения по условию не было)следовательно, данное предусловие не нужно.

для команды: public T removeHead();( //предусловие: очередь создается впервые) сформирована не верно,
предусловие – очередь не пуста, ведь только при непустой очереди возможно выполнение этой команды.
(если представить, что сигнатура определена верно, и не смешивается в одном методе команда и запрос)


4.Постусловия.

для команды: public void putTail(T value);
(//постусловие: размер очереди увеличивается на один элемент)сформировано не верно.
Т.к. в хвост очереди добавлен один элемент, мы же выполняем именно команду добавления в хвост очереди.

для команды: public T removeHead();
(//постусловие: размер очереди уменьшается на один элемент) сформировано не верно.
Т.к. выполняется команда удаления одного элемента из головы и соответственно,
постусловие: из головы очереди удален элемент.


5. Конструктор.
Конструктор и постусловие выполнены верно.


6. Определим какие функции являются командами, а какие запросами.

команда: public void putTail(T value); - верно,
запрос: public int size();(чистая функция)- верно

7. Определим отдельные (дополнительные) запросы для статуса команд.

//запросы
public int size(); //отсутствует комментарий

•	отсутствует полностью, из-за неверной сигнатуры метода удаления:
// предусловие: очередь не пуста;
// постусловие: из головы очереди удалён элемент
  public void dequeue();

•	лишний запрос, т.к. отсутствует предусловие (в эталонном решении)
    //запросы статусов
    public int get_put_tail_status(); // возвращает значение PUT_TAIL_*

•	неверный запрос статуса(не верная сигнатура метода)

    public int get_remove_head_status(); // возвращает значение REMOVE_HEAD_*

Рефлексия задания 6.
Разбирать родительский АТД и говорить, что он верен –
не уместно, т.к. это, материалы предыдущего задания.
Если просто на листе, выписать функции родительского АТД и АТД Deque,
то в наследнике появляются функции: добавить элемент в голову и удалить элемент из хвоста.
Затем необходимо провести анализ функций на пред и постусловия.
И если, у функций будут предусловия – реализовать запросы статусов этих функций
на выполнение предусловий.
Иначе говоря, необходимы условия (границы, рамки)
при выполнении/соблюдении которых УСПЕШНО выполнится предусловие или С ОШИБКОЙ.

Не указано постусловие для конструктора :
// постусловие: создана пустая очередь
  public Deque<T> Deque();

не реализована команда, удаление элемента из хвоста:
// предусловие: очередь не пуста;
// постусловие: из хвоста очереди удалён элемент
  public void remove_tail();
а так как эта команда имеет предусловие, соответственно и не реализован запрос статуса этой команды.
Команда не реализована из-за неверного представления работы двусторонней очереди.

Рефлексия задания 7

*В скобках приведены верные решения.

1. Тип АТД определен верно.
HashTable<T>

2. Сформируем сигнатуры всех методов АТД (без их реализации):
abstract class HashTable<T>

    public int hashFun(T value); // метод ненужен т.к. по условию у нас есть система коллизий.
    public void put(T value); // сформирован верно
    public void remove(T value); // сформирован верно
    // сформирован не верно (public bool get(T value);)т.к. нужно не возвращать значение,
    а выполнять проверку на присутствие значения в хэш-таблице
    public T find(T value);

    public int size(); // сформирован верно

3. Для каждого метода (при необходимости) задаем набор условий, ограничений на его работу (ПРЕДУСЛОВИЯ)

    //предусловие: таблица не пуста - не корректное предусловие (в таблице имеется свободный слот для value;)
    здесь неверно было бы написать, что в таблице отсутствует value - т.к. мы кладем в таблицу случайные значения.
    Для этого и существует система коллизий.
    public void put(T value);

    // предусловие: таблица не пуста - не корректное предусловие (в таблице имеется значение value;)
    Т.к. удаляем определенное значение value.
    public void remove(T value);

4. Определим, что в объекте меняется после вызова того или иного метода (ПОСТУСЛОВИЯ)
    Выпишем функции для которых есть постусловия.

    //постусловие: в таблицу добавился один элемент (емкость уменьшилась)
    - не корректное постусловие(в таблицу добавлено новое значение) и емкость не нужна, т.к. это уже реализация метода.
    public void put(T value);

    //постусловие: таблица уменьшилась на один элемент (емкость увеличилась)
    - не корректное постусловие (из таблицы удалено значение value)
    public remove(T value);

5. Конструктор.
    Объекты создаются вызовом особой функции класса.

    // конструктор
    // постусловие: создана пустая таблица - не корректное (создана пустая хэш-таблица заданного размера).
    Согласно заданию, фиксированный размер, определенный в конструкторе.
    Соответственно и конструктор - не верный (public HashTable<T> HashTable(int sz);).
    public HashTable<T> HashTable();

6. Определим какие функции являются командами а какие запросами (пересмотрим методы)

    public int hashFun(T value); - не верно (т.к. это уже реализация АТД)

    public void put(T value); //команда - верно

    public remove(T value); //команда - верно

    public T find(T value); запрос (чистая функция) - не верно, т.к. сама функция спроектирована не верно.

    public int size(); // запрос (чистая функция) - верно

    public int capacity(); // запрос (чистая функция)  - не нужен (т.к. это уже реализация АТД)


7. Определим отдельные (дополнительные) запросы для статуса команд.
    Возвращают статус выполнения команд у которых есть ПРЕДУСЛОВИЯ.
    Выпишем команды имеющие предусловия и требующие дополнительных запросов.

        //предусловие: hashFun вернул свободный слот - не верно
        public void put(T value); //команда

        public const int PUT_OK = 1; // последний put отработал нормально (успешно) - верно

        // hashFun вернул не свободный слот - не верный комментарий
        (система коллизий не смогла найти свободный слот для значения)
        public const int PUT_ER = 2;

        //предусловие: таблица не пуста - не верно
        //постусловие: таблица уменьшилась на один элемент (емкость увеличилась) - не верно
        public remove(T value); //команда

        public const int REMOVE_OK = 1; // последний remove отработал нормально (успешно) - верно
        public const int REMOVE_ER = 2; // таблица пуста - верно

        // предусловие: таблица не пуста
        public T find(T value); //запрос (чистая функция)

        //запросы статусов
        // успешно; hashFun вернул не свободный слот - не верно
        public int get_put_status();  - наименование верно

        // успешно; таблица пуста - верно
        public int get_remove_status(); - наименование верно


Рефлексия задания 8.

Решение задания 8 не верно.
Разберемся, почему это так.

    //команды
    //предусловие: в ассоциативном массиве имеется свободный слот для value
    //постусловие: в ассоциативный массив добавлена новое value
    public void putInMap(String Key, T value);
Так, эта команда спроектирована верно, но, предусловия не будет – т.к. если ключ отсутствовал,
добавится пара ключ-значение, если ключ есть – то значение обновится.
Иначе говоря, у нас нет таких ограничений, которые можно было бы нарушить при добавлении пары ключ-значение.
Постусловие не корректно из-за того, что подразумевалось - система коллизий ищет свободный слот для ключа
и найдя его, ключ кладется в этот слот, а значение кладется в такой же слот,
но массива значений. В случае, если слот занят – значение просто бы обновилось.
Ошибка в том, что родительский класс (как предполагалось, для хода решения) умеет обрабатывать значения
(добавлять, удалять, проверять на наличие) а в данной задаче было необходимо работать
со строковыми значениями ключа (работать с ключом, а не со значениями).
Соответственно и в эталонном решении, операции remove, get, is_key принимают строковые значения
ключа и именно по ключу мы выполняем операции со значением.


Рефлексия задания 9.

Абстрактный класс определен верно: abstract class PowerSet<T> extends HashTable<T>
Конструктор: public PowerSet<T> PowerSet(int sz);
и постусловие: создано пустое множество на максимальное количество элементов sz
определены верно.
Функции определены верно, но они не являются командами. Команд в классе-наследнике вообще нет.
Соответственно и запросы статусов не верны, т.к. нет предусловий.
Функции, корректно и полностью определены на типе данных, замкнутые на множество.
Функции определил в классы ошибочно - они не меняют состояние класса,
при их выполнении ничего не добавляется или убавляется, либо как то меняется.
У нас есть множество и оно не меняется, результатом работы функций являются новые множества.
Конструктор реализовал ошибочно, из-за того, что "ушел" в реализацию,
а там соответственно различия для хэш таблицы (на массиве)
а для множества на списке.